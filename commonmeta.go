// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "encoding/json"
import "fmt"
import "reflect"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaGeoLocationsElemGeoLocationBox) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eastBoundLongitude"]; !ok || v == nil {
		return fmt.Errorf("field eastBoundLongitude in CommonmetaGeoLocationsElemGeoLocationBox: required")
	}
	if v, ok := raw["northBoundLatitude"]; !ok || v == nil {
		return fmt.Errorf("field northBoundLatitude in CommonmetaGeoLocationsElemGeoLocationBox: required")
	}
	if v, ok := raw["southBoundLatitude"]; !ok || v == nil {
		return fmt.Errorf("field southBoundLatitude in CommonmetaGeoLocationsElemGeoLocationBox: required")
	}
	if v, ok := raw["westBoundLongitude"]; !ok || v == nil {
		return fmt.Errorf("field westBoundLongitude in CommonmetaGeoLocationsElemGeoLocationBox: required")
	}
	type Plain CommonmetaGeoLocationsElemGeoLocationBox
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaGeoLocationsElemGeoLocationBox(plain)
	return nil
}

const CommonmetaStateFindable CommonmetaState = "findable"

// UnmarshalJSON implements json.Unmarshaler.
func (j *Commonmeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in Commonmeta: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in Commonmeta: required")
	}
	type Plain Commonmeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Contributors != nil && len(plain.Contributors) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contributors", 1)
	}
	*j = Commonmeta(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContributorRole) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContributorRole {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContributorRole, v)
	}
	*j = ContributorRole(v)
	return nil
}

// JSON representation of the Commonmeta schema.
type Commonmeta struct {
	// The additional type of the resource.
	AdditionalType *string `json:"additional_type,omitempty" yaml:"additional_type,omitempty" mapstructure:"additional_type,omitempty"`

	// Alternate identifiers for the resource.
	AlternateIdentifiers []CommonmetaAlternateIdentifiersElem `json:"alternate_identifiers,omitempty" yaml:"alternate_identifiers,omitempty" mapstructure:"alternate_identifiers,omitempty"`

	// The location where content is archived.
	ArchiveLocations []CommonmetaArchiveLocationsElem `json:"archive_locations,omitempty" yaml:"archive_locations,omitempty" mapstructure:"archive_locations,omitempty"`

	// The container of the resource.
	Container *CommonmetaContainer `json:"container,omitempty" yaml:"container,omitempty" mapstructure:"container,omitempty"`

	// The contributors to the resource.
	Contributors []CommonmetaContributorsElem `json:"contributors,omitempty" yaml:"contributors,omitempty" mapstructure:"contributors,omitempty"`

	// The dates for the resource.
	Date *CommonmetaDate `json:"date,omitempty" yaml:"date,omitempty" mapstructure:"date,omitempty"`

	// The descriptions of the resource.
	Descriptions []CommonmetaDescriptionsElem `json:"descriptions,omitempty" yaml:"descriptions,omitempty" mapstructure:"descriptions,omitempty"`

	// The downloadable files for the resource.
	Files []CommonmetaFilesElem `json:"files,omitempty" yaml:"files,omitempty" mapstructure:"files,omitempty"`

	// The formats of the resource.
	Formats []string `json:"formats,omitempty" yaml:"formats,omitempty" mapstructure:"formats,omitempty"`

	// The funding references for the resource.
	FundingReferences []CommonmetaFundingReferencesElem `json:"funding_references,omitempty" yaml:"funding_references,omitempty" mapstructure:"funding_references,omitempty"`

	// GeoLocations corresponds to the JSON schema field "geo_locations".
	GeoLocations []CommonmetaGeoLocationsElem `json:"geo_locations,omitempty" yaml:"geo_locations,omitempty" mapstructure:"geo_locations,omitempty"`

	// The unique identifier for the resource.
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The language of the resource. Use one of the language codes from the IETF BCP
	// 47 standard.
	Language *string `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`

	// The license for the resource. Use one of the SPDX license identifiers.
	License *CommonmetaLicense `json:"license,omitempty" yaml:"license,omitempty" mapstructure:"license,omitempty"`

	// The provider of the resource. This can be a DOI registration agency or a
	// repository.
	Provider *CommonmetaProvider `json:"provider,omitempty" yaml:"provider,omitempty" mapstructure:"provider,omitempty"`

	// The publisher of the resource.
	Publisher *CommonmetaPublisher `json:"publisher,omitempty" yaml:"publisher,omitempty" mapstructure:"publisher,omitempty"`

	// References corresponds to the JSON schema field "references".
	References []CommonmetaReferencesElem `json:"references,omitempty" yaml:"references,omitempty" mapstructure:"references,omitempty"`

	// Other resolvable persistent unique IDs related to the resource.
	Relations []CommonmetaRelationsElem `json:"relations,omitempty" yaml:"relations,omitempty" mapstructure:"relations,omitempty"`

	// The schema version of the resource.
	SchemaVersion *CommonmetaSchemaVersion `json:"schema_version,omitempty" yaml:"schema_version,omitempty" mapstructure:"schema_version,omitempty"`

	// The sizes of the resource.
	Sizes []string `json:"sizes,omitempty" yaml:"sizes,omitempty" mapstructure:"sizes,omitempty"`

	// The state of the resource.
	State *CommonmetaState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// Subjects corresponds to the JSON schema field "subjects".
	Subjects []CommonmetaSubjectsElem `json:"subjects,omitempty" yaml:"subjects,omitempty" mapstructure:"subjects,omitempty"`

	// The titles of the resource.
	Titles []CommonmetaTitlesElem `json:"titles,omitempty" yaml:"titles,omitempty" mapstructure:"titles,omitempty"`

	// The type of the resource.
	Type CommonmetaType `json:"type" yaml:"type" mapstructure:"type"`

	// The URL of the resource.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// The version of the resource.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type Affiliations []struct {
	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaType, v)
	}
	*j = CommonmetaType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaTitlesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["title"]; !ok || v == nil {
		return fmt.Errorf("field title in CommonmetaTitlesElem: required")
	}
	type Plain CommonmetaTitlesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaTitlesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaTitlesElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaTitlesElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaTitlesElemType, v)
	}
	*j = CommonmetaTitlesElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaSubjectsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["subject"]; !ok || v == nil {
		return fmt.Errorf("field subject in CommonmetaSubjectsElem: required")
	}
	type Plain CommonmetaSubjectsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaSubjectsElem(plain)
	return nil
}

const CommonmetaStateBadRequest CommonmetaState = "bad_request"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaGeoLocationsElemGeoLocationPolygonsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["polygonPoints"]; !ok || v == nil {
		return fmt.Errorf("field polygonPoints in CommonmetaGeoLocationsElemGeoLocationPolygonsElem: required")
	}
	type Plain CommonmetaGeoLocationsElemGeoLocationPolygonsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.PolygonPoints != nil && len(plain.PolygonPoints) < 4 {
		return fmt.Errorf("field %s length: must be >= %d", "polygonPoints", 4)
	}
	*j = CommonmetaGeoLocationsElemGeoLocationPolygonsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaState, v)
	}
	*j = CommonmetaState(v)
	return nil
}

type CommonmetaState string

const CommonmetaSchemaVersionHttpDataciteOrgSchemaKernel4 CommonmetaSchemaVersion = "http://datacite.org/schema/kernel-4"
const CommonmetaSchemaVersionHttpDataciteOrgSchemaKernel3 CommonmetaSchemaVersion = "http://datacite.org/schema/kernel-3"
const CommonmetaSchemaVersionHttpsCommonmetaOrgCommonmetaV012 CommonmetaSchemaVersion = "https://commonmeta.org/commonmeta_v0.12"
const CommonmetaSchemaVersionHttpsCommonmetaOrgCommonmetaV011 CommonmetaSchemaVersion = "https://commonmeta.org/commonmeta_v0.11"
const CommonmetaSchemaVersionHttpsCommonmetaOrgCommonmetaV010 CommonmetaSchemaVersion = "https://commonmeta.org/commonmeta_v0.10"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaSchemaVersion) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaSchemaVersion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaSchemaVersion, v)
	}
	*j = CommonmetaSchemaVersion(v)
	return nil
}

type CommonmetaSchemaVersion string

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaRelationsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in CommonmetaRelationsElem: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in CommonmetaRelationsElem: required")
	}
	type Plain CommonmetaRelationsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaRelationsElem(plain)
	return nil
}

type CommonmetaRelationsElem struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Type corresponds to the JSON schema field "type".
	Type CommonmetaRelationsElemType `json:"type" yaml:"type" mapstructure:"type"`
}

const CommonmetaRelationsElemTypeIsSupplementedBy CommonmetaRelationsElemType = "IsSupplementedBy"
const CommonmetaRelationsElemTypeIsSupplementTo CommonmetaRelationsElemType = "IsSupplementTo"
const CommonmetaRelationsElemTypeHasPreprint CommonmetaRelationsElemType = "HasPreprint"
const CommonmetaRelationsElemTypeIsPreprintOf CommonmetaRelationsElemType = "IsPreprintOf"
const CommonmetaRelationsElemTypeHasReview CommonmetaRelationsElemType = "HasReview"
const CommonmetaRelationsElemTypeReviews CommonmetaRelationsElemType = "Reviews"
const CommonmetaRelationsElemTypeIsReviewedBy CommonmetaRelationsElemType = "IsReviewedBy"
const CommonmetaRelationsElemTypeHasTranslation CommonmetaRelationsElemType = "HasTranslation"
const CommonmetaRelationsElemTypeIsTranslationOf CommonmetaRelationsElemType = "IsTranslationOf"
const CommonmetaRelationsElemTypeIsIdenticalTo CommonmetaRelationsElemType = "IsIdenticalTo"
const CommonmetaRelationsElemTypeIsOriginalFormOf CommonmetaRelationsElemType = "IsOriginalFormOf"
const CommonmetaRelationsElemTypeIsVariantFormOf CommonmetaRelationsElemType = "IsVariantFormOf"
const CommonmetaRelationsElemTypeHasPart CommonmetaRelationsElemType = "HasPart"
const CommonmetaRelationsElemTypeIsPartOf CommonmetaRelationsElemType = "IsPartOf"
const CommonmetaRelationsElemTypeHasVersion CommonmetaRelationsElemType = "HasVersion"
const CommonmetaRelationsElemTypeIsVersionOf CommonmetaRelationsElemType = "IsVersionOf"

type CommonmetaGeoLocationsElemGeoLocationPolygonsElem struct {
	// InPolygonPoint corresponds to the JSON schema field "inPolygonPoint".
	InPolygonPoint *GeoLocationPoint `json:"inPolygonPoint,omitempty" yaml:"inPolygonPoint,omitempty" mapstructure:"inPolygonPoint,omitempty"`

	// PolygonPoints corresponds to the JSON schema field "polygonPoints".
	PolygonPoints []GeoLocationPoint `json:"polygonPoints" yaml:"polygonPoints" mapstructure:"polygonPoints"`
}

const CommonmetaRelationsElemTypeIsNewVersionOf CommonmetaRelationsElemType = "IsNewVersionOf"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaRelationsElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaRelationsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaRelationsElemType, v)
	}
	*j = CommonmetaRelationsElemType(v)
	return nil
}

type CommonmetaRelationsElemType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaReferencesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key in CommonmetaReferencesElem: required")
	}
	type Plain CommonmetaReferencesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaReferencesElem(plain)
	return nil
}

type CommonmetaReferencesElem struct {
	// ContainerTitle corresponds to the JSON schema field "containerTitle".
	ContainerTitle *string `json:"containerTitle,omitempty" yaml:"containerTitle,omitempty" mapstructure:"containerTitle,omitempty"`

	// Contributor corresponds to the JSON schema field "contributor".
	Contributor *string `json:"contributor,omitempty" yaml:"contributor,omitempty" mapstructure:"contributor,omitempty"`

	// Doi corresponds to the JSON schema field "doi".
	Doi *string `json:"doi,omitempty" yaml:"doi,omitempty" mapstructure:"doi,omitempty"`

	// Edition corresponds to the JSON schema field "edition".
	Edition *string `json:"edition,omitempty" yaml:"edition,omitempty" mapstructure:"edition,omitempty"`

	// FirstPage corresponds to the JSON schema field "firstPage".
	FirstPage *string `json:"firstPage,omitempty" yaml:"firstPage,omitempty" mapstructure:"firstPage,omitempty"`

	// Issue corresponds to the JSON schema field "issue".
	Issue *string `json:"issue,omitempty" yaml:"issue,omitempty" mapstructure:"issue,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// LastPage corresponds to the JSON schema field "lastPage".
	LastPage *string `json:"lastPage,omitempty" yaml:"lastPage,omitempty" mapstructure:"lastPage,omitempty"`

	// PublicationYear corresponds to the JSON schema field "publicationYear".
	PublicationYear *string `json:"publicationYear,omitempty" yaml:"publicationYear,omitempty" mapstructure:"publicationYear,omitempty"`

	// Publisher corresponds to the JSON schema field "publisher".
	Publisher *string `json:"publisher,omitempty" yaml:"publisher,omitempty" mapstructure:"publisher,omitempty"`

	// Title corresponds to the JSON schema field "title".
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// Unstructured corresponds to the JSON schema field "unstructured".
	Unstructured *string `json:"unstructured,omitempty" yaml:"unstructured,omitempty" mapstructure:"unstructured,omitempty"`

	// Volume corresponds to the JSON schema field "volume".
	Volume *string `json:"volume,omitempty" yaml:"volume,omitempty" mapstructure:"volume,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaPublisher) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in CommonmetaPublisher: required")
	}
	type Plain CommonmetaPublisher
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaPublisher(plain)
	return nil
}

// The publisher of the resource.
type CommonmetaPublisher struct {
	// The identifier for the publisher.
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The name of the publisher.
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

const CommonmetaProviderInvenioRDM CommonmetaProvider = "InvenioRDM"
const CommonmetaProviderOP CommonmetaProvider = "OP"

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeoLocationPoint) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pointLatitude"]; !ok || v == nil {
		return fmt.Errorf("field pointLatitude in GeoLocationPoint: required")
	}
	if v, ok := raw["pointLongitude"]; !ok || v == nil {
		return fmt.Errorf("field pointLongitude in GeoLocationPoint: required")
	}
	type Plain GeoLocationPoint
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GeoLocationPoint(plain)
	return nil
}

type CommonmetaAlternateIdentifiersElem struct {
	// AlternateIdentifier corresponds to the JSON schema field "alternateIdentifier".
	AlternateIdentifier string `json:"alternateIdentifier" yaml:"alternateIdentifier" mapstructure:"alternateIdentifier"`

	// AlternateIdentifierType corresponds to the JSON schema field
	// "alternateIdentifierType".
	AlternateIdentifierType string `json:"alternateIdentifierType" yaml:"alternateIdentifierType" mapstructure:"alternateIdentifierType"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaAlternateIdentifiersElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["alternateIdentifier"]; !ok || v == nil {
		return fmt.Errorf("field alternateIdentifier in CommonmetaAlternateIdentifiersElem: required")
	}
	if v, ok := raw["alternateIdentifierType"]; !ok || v == nil {
		return fmt.Errorf("field alternateIdentifierType in CommonmetaAlternateIdentifiersElem: required")
	}
	type Plain CommonmetaAlternateIdentifiersElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaAlternateIdentifiersElem(plain)
	return nil
}

type CommonmetaArchiveLocationsElem string

const CommonmetaProviderMEDRA CommonmetaProvider = "mEDRA"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaArchiveLocationsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaArchiveLocationsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaArchiveLocationsElem, v)
	}
	*j = CommonmetaArchiveLocationsElem(v)
	return nil
}

const CommonmetaArchiveLocationsElemCLOCKSS CommonmetaArchiveLocationsElem = "CLOCKSS"
const CommonmetaArchiveLocationsElemLOCKSS CommonmetaArchiveLocationsElem = "LOCKSS"
const CommonmetaArchiveLocationsElemPortico CommonmetaArchiveLocationsElem = "Portico"
const CommonmetaArchiveLocationsElemKB CommonmetaArchiveLocationsElem = "KB"
const CommonmetaArchiveLocationsElemInternetArchive CommonmetaArchiveLocationsElem = "Internet Archive"
const CommonmetaArchiveLocationsElemDWT CommonmetaArchiveLocationsElem = "DWT"

type CommonmetaContainerType string

const CommonmetaProviderKISTI CommonmetaProvider = "KISTI"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaContainerType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaContainerType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaContainerType, v)
	}
	*j = CommonmetaContainerType(v)
	return nil
}

const CommonmetaContainerTypeBook CommonmetaContainerType = "Book"
const CommonmetaContainerTypeBookSeries CommonmetaContainerType = "BookSeries"
const CommonmetaContainerTypeJournal CommonmetaContainerType = "Journal"
const CommonmetaContainerTypeProceedings CommonmetaContainerType = "Proceedings"
const CommonmetaContainerTypeProceedingsSeries CommonmetaContainerType = "ProceedingsSeries"
const CommonmetaContainerTypeRepository CommonmetaContainerType = "Repository"
const CommonmetaContainerTypeDataRepository CommonmetaContainerType = "DataRepository"
const CommonmetaContainerTypePeriodical CommonmetaContainerType = "Periodical"
const CommonmetaContainerTypeSeries CommonmetaContainerType = "Series"

// The container of the resource.
type CommonmetaContainer struct {
	// The first page of the resource.
	FirstPage *string `json:"firstPage,omitempty" yaml:"firstPage,omitempty" mapstructure:"firstPage,omitempty"`

	// The identifier for the container.
	Identifier *string `json:"identifier,omitempty" yaml:"identifier,omitempty" mapstructure:"identifier,omitempty"`

	// The identifierType for the container.
	IdentifierType *string `json:"identifierType,omitempty" yaml:"identifierType,omitempty" mapstructure:"identifierType,omitempty"`

	// The issue of the resource.
	Issue *string `json:"issue,omitempty" yaml:"issue,omitempty" mapstructure:"issue,omitempty"`

	// The last page of the resource.
	LastPage *string `json:"lastPage,omitempty" yaml:"lastPage,omitempty" mapstructure:"lastPage,omitempty"`

	// The title of the container.
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// The type of the container.
	Type *CommonmetaContainerType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// The volume of the resource.
	Volume *string `json:"volume,omitempty" yaml:"volume,omitempty" mapstructure:"volume,omitempty"`
}

type CommonmetaContributorsElemType string

const CommonmetaProviderJaLC CommonmetaProvider = "JaLC"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaContributorsElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaContributorsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaContributorsElemType, v)
	}
	*j = CommonmetaContributorsElemType(v)
	return nil
}

const CommonmetaContributorsElemTypeOrganization CommonmetaContributorsElemType = "Organization"
const CommonmetaContributorsElemTypePerson CommonmetaContributorsElemType = "Person"

type CommonmetaContributorsElem struct {
	// Affiliation corresponds to the JSON schema field "affiliation".
	Affiliation Affiliations `json:"affiliation,omitempty" yaml:"affiliation,omitempty" mapstructure:"affiliation,omitempty"`

	// List of roles assumed by the contributor when working on the resource.
	ContributorRoles []ContributorRole `json:"contributorRoles" yaml:"contributorRoles" mapstructure:"contributorRoles"`

	// The family name of the contributor.
	FamilyName *string `json:"familyName,omitempty" yaml:"familyName,omitempty" mapstructure:"familyName,omitempty"`

	// The given name of the contributor.
	GivenName *string `json:"givenName,omitempty" yaml:"givenName,omitempty" mapstructure:"givenName,omitempty"`

	// The unique identifier for the contributor.
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The name of the contributor.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The type of the contributor.
	Type CommonmetaContributorsElemType `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaContributorsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contributorRoles"]; !ok || v == nil {
		return fmt.Errorf("field contributorRoles in CommonmetaContributorsElem: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in CommonmetaContributorsElem: required")
	}
	type Plain CommonmetaContributorsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaContributorsElem(plain)
	return nil
}

// The dates for the resource.
type CommonmetaDate struct {
	// The date the resource was accepted.
	Accepted *string `json:"accepted,omitempty" yaml:"accepted,omitempty" mapstructure:"accepted,omitempty"`

	// The date the resource was accessed.
	Accessed *string `json:"accessed,omitempty" yaml:"accessed,omitempty" mapstructure:"accessed,omitempty"`

	// The date the resource was made available.
	Available *string `json:"available,omitempty" yaml:"available,omitempty" mapstructure:"available,omitempty"`

	// The date the resource was created.
	Created *string `json:"created,omitempty" yaml:"created,omitempty" mapstructure:"created,omitempty"`

	// The date the resource was published.
	Published *string `json:"published,omitempty" yaml:"published,omitempty" mapstructure:"published,omitempty"`

	// The date the resource was submitted.
	Submitted *string `json:"submitted,omitempty" yaml:"submitted,omitempty" mapstructure:"submitted,omitempty"`

	// The date the resource was updated.
	Updated *string `json:"updated,omitempty" yaml:"updated,omitempty" mapstructure:"updated,omitempty"`

	// The date the resource was withdrawn.
	Withdrawn *string `json:"withdrawn,omitempty" yaml:"withdrawn,omitempty" mapstructure:"withdrawn,omitempty"`
}

type CommonmetaDescriptionsElemType string

const CommonmetaProviderGitHub CommonmetaProvider = "GitHub"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaDescriptionsElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaDescriptionsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaDescriptionsElemType, v)
	}
	*j = CommonmetaDescriptionsElemType(v)
	return nil
}

const CommonmetaDescriptionsElemTypeAbstract CommonmetaDescriptionsElemType = "Abstract"
const CommonmetaDescriptionsElemTypeSummary CommonmetaDescriptionsElemType = "Summary"
const CommonmetaDescriptionsElemTypeMethods CommonmetaDescriptionsElemType = "Methods"
const CommonmetaDescriptionsElemTypeTechnicalInfo CommonmetaDescriptionsElemType = "TechnicalInfo"
const CommonmetaDescriptionsElemTypeOther CommonmetaDescriptionsElemType = "Other"

type CommonmetaDescriptionsElem struct {
	// The description of the resource.
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// The language of the title. Use one of the language codes from the IETF BCP 47
	// standard.
	Language *string `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`

	// The type of the description.
	Type *CommonmetaDescriptionsElemType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaDescriptionsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description in CommonmetaDescriptionsElem: required")
	}
	type Plain CommonmetaDescriptionsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaDescriptionsElem(plain)
	return nil
}

type CommonmetaFilesElem struct {
	// Bucket corresponds to the JSON schema field "bucket".
	Bucket *string `json:"bucket,omitempty" yaml:"bucket,omitempty" mapstructure:"bucket,omitempty"`

	// Checksum corresponds to the JSON schema field "checksum".
	Checksum *string `json:"checksum,omitempty" yaml:"checksum,omitempty" mapstructure:"checksum,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// MimeType corresponds to the JSON schema field "mimeType".
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// Size corresponds to the JSON schema field "size".
	Size *int `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaFilesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in CommonmetaFilesElem: required")
	}
	type Plain CommonmetaFilesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaFilesElem(plain)
	return nil
}

type CommonmetaFundingReferencesElemFunderIdentifierType string

const CommonmetaProviderDataCite CommonmetaProvider = "DataCite"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaFundingReferencesElemFunderIdentifierType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaFundingReferencesElemFunderIdentifierType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaFundingReferencesElemFunderIdentifierType, v)
	}
	*j = CommonmetaFundingReferencesElemFunderIdentifierType(v)
	return nil
}

const CommonmetaFundingReferencesElemFunderIdentifierTypeCrossrefFunderID CommonmetaFundingReferencesElemFunderIdentifierType = "Crossref Funder ID"
const CommonmetaFundingReferencesElemFunderIdentifierTypeROR CommonmetaFundingReferencesElemFunderIdentifierType = "ROR"
const CommonmetaFundingReferencesElemFunderIdentifierTypeGRID CommonmetaFundingReferencesElemFunderIdentifierType = "GRID"
const CommonmetaFundingReferencesElemFunderIdentifierTypeISNI CommonmetaFundingReferencesElemFunderIdentifierType = "ISNI"
const CommonmetaFundingReferencesElemFunderIdentifierTypeRinggold CommonmetaFundingReferencesElemFunderIdentifierType = "Ringgold"
const CommonmetaFundingReferencesElemFunderIdentifierTypeOther CommonmetaFundingReferencesElemFunderIdentifierType = "Other"

type CommonmetaFundingReferencesElem struct {
	// AwardNumber corresponds to the JSON schema field "awardNumber".
	AwardNumber *string `json:"awardNumber,omitempty" yaml:"awardNumber,omitempty" mapstructure:"awardNumber,omitempty"`

	// AwardUri corresponds to the JSON schema field "award_uri".
	AwardUri *string `json:"award_uri,omitempty" yaml:"award_uri,omitempty" mapstructure:"award_uri,omitempty"`

	// FunderIdentifier corresponds to the JSON schema field "funderIdentifier".
	FunderIdentifier *string `json:"funderIdentifier,omitempty" yaml:"funderIdentifier,omitempty" mapstructure:"funderIdentifier,omitempty"`

	// FunderIdentifierType corresponds to the JSON schema field
	// "funderIdentifierType".
	FunderIdentifierType *CommonmetaFundingReferencesElemFunderIdentifierType `json:"funderIdentifierType,omitempty" yaml:"funderIdentifierType,omitempty" mapstructure:"funderIdentifierType,omitempty"`

	// FunderName corresponds to the JSON schema field "funderName".
	FunderName string `json:"funderName" yaml:"funderName" mapstructure:"funderName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaFundingReferencesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["funderName"]; !ok || v == nil {
		return fmt.Errorf("field funderName in CommonmetaFundingReferencesElem: required")
	}
	type Plain CommonmetaFundingReferencesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommonmetaFundingReferencesElem(plain)
	return nil
}

type CommonmetaGeoLocationsElemGeoLocationBox struct {
	// EastBoundLongitude corresponds to the JSON schema field "eastBoundLongitude".
	EastBoundLongitude Longitude `json:"eastBoundLongitude" yaml:"eastBoundLongitude" mapstructure:"eastBoundLongitude"`

	// NorthBoundLatitude corresponds to the JSON schema field "northBoundLatitude".
	NorthBoundLatitude Latitude `json:"northBoundLatitude" yaml:"northBoundLatitude" mapstructure:"northBoundLatitude"`

	// SouthBoundLatitude corresponds to the JSON schema field "southBoundLatitude".
	SouthBoundLatitude Latitude `json:"southBoundLatitude" yaml:"southBoundLatitude" mapstructure:"southBoundLatitude"`

	// WestBoundLongitude corresponds to the JSON schema field "westBoundLongitude".
	WestBoundLongitude Longitude `json:"westBoundLongitude" yaml:"westBoundLongitude" mapstructure:"westBoundLongitude"`
}

const CommonmetaProviderCrossref CommonmetaProvider = "Crossref"
const CommonmetaRelationsElemTypeIsPreviousVersionOf CommonmetaRelationsElemType = "IsPreviousVersionOf"

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommonmetaProvider) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CommonmetaProvider {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CommonmetaProvider, v)
	}
	*j = CommonmetaProvider(v)
	return nil
}

type CommonmetaGeoLocationsElem struct {
	// GeoLocationBox corresponds to the JSON schema field "geoLocationBox".
	GeoLocationBox *CommonmetaGeoLocationsElemGeoLocationBox `json:"geoLocationBox,omitempty" yaml:"geoLocationBox,omitempty" mapstructure:"geoLocationBox,omitempty"`

	// GeoLocationPlace corresponds to the JSON schema field "geoLocationPlace".
	GeoLocationPlace *string `json:"geoLocationPlace,omitempty" yaml:"geoLocationPlace,omitempty" mapstructure:"geoLocationPlace,omitempty"`

	// GeoLocationPoint corresponds to the JSON schema field "geoLocationPoint".
	GeoLocationPoint *GeoLocationPoint `json:"geoLocationPoint,omitempty" yaml:"geoLocationPoint,omitempty" mapstructure:"geoLocationPoint,omitempty"`

	// GeoLocationPolygons corresponds to the JSON schema field "geoLocationPolygons".
	GeoLocationPolygons []CommonmetaGeoLocationsElemGeoLocationPolygonsElem `json:"geoLocationPolygons,omitempty" yaml:"geoLocationPolygons,omitempty" mapstructure:"geoLocationPolygons,omitempty"`
}

// The license for the resource. Use one of the SPDX license identifiers.
type CommonmetaLicense struct {
	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type CommonmetaProvider string

const CommonmetaStateForbidden CommonmetaState = "forbidden"
const CommonmetaStateNotFound CommonmetaState = "not_found"

type CommonmetaSubjectsElem struct {
	// Subject corresponds to the JSON schema field "subject".
	Subject string `json:"subject" yaml:"subject" mapstructure:"subject"`
}

type CommonmetaTitlesElem struct {
	// The language of the title. Use one of the language codes from the IETF BCP 47
	// standard.
	Language *string `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`

	// The title of the resource.
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// The type of the title.
	Type *CommonmetaTitlesElemType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type CommonmetaTitlesElemType string

const CommonmetaTitlesElemTypeAlternativeTitle CommonmetaTitlesElemType = "AlternativeTitle"
const CommonmetaTitlesElemTypeSubtitle CommonmetaTitlesElemType = "Subtitle"
const CommonmetaTitlesElemTypeTranslatedTitle CommonmetaTitlesElemType = "TranslatedTitle"

type CommonmetaType string

const CommonmetaTypeArticle CommonmetaType = "Article"
const CommonmetaTypeAudiovisual CommonmetaType = "Audiovisual"
const CommonmetaTypeBook CommonmetaType = "Book"
const CommonmetaTypeBookChapter CommonmetaType = "BookChapter"
const CommonmetaTypeBookPart CommonmetaType = "BookPart"
const CommonmetaTypeBookSection CommonmetaType = "BookSection"
const CommonmetaTypeBookSeries CommonmetaType = "BookSeries"
const CommonmetaTypeBookSet CommonmetaType = "BookSet"
const CommonmetaTypeCollection CommonmetaType = "Collection"
const CommonmetaTypeComponent CommonmetaType = "Component"
const CommonmetaTypeDatabase CommonmetaType = "Database"
const CommonmetaTypeDataset CommonmetaType = "Dataset"
const CommonmetaTypeDissertation CommonmetaType = "Dissertation"
const CommonmetaTypeDocument CommonmetaType = "Document"
const CommonmetaTypeEntry CommonmetaType = "Entry"
const CommonmetaTypeGrant CommonmetaType = "Grant"
const CommonmetaTypeImage CommonmetaType = "Image"
const CommonmetaTypeInstrument CommonmetaType = "Instrument"
const CommonmetaTypeJournal CommonmetaType = "Journal"
const CommonmetaTypeJournalArticle CommonmetaType = "JournalArticle"
const CommonmetaTypeJournalIssue CommonmetaType = "JournalIssue"
const CommonmetaTypeJournalVolume CommonmetaType = "JournalVolume"
const CommonmetaTypeOther CommonmetaType = "Other"
const CommonmetaTypePeerReview CommonmetaType = "PeerReview"
const CommonmetaTypePhysicalObject CommonmetaType = "PhysicalObject"
const CommonmetaTypePresentation CommonmetaType = "Presentation"
const CommonmetaTypeProceedings CommonmetaType = "Proceedings"
const CommonmetaTypeProceedingsArticle CommonmetaType = "ProceedingsArticle"
const CommonmetaTypeProceedingsSeries CommonmetaType = "ProceedingsSeries"
const CommonmetaTypeReport CommonmetaType = "Report"
const CommonmetaTypeReportComponent CommonmetaType = "ReportComponent"
const CommonmetaTypeReportSeries CommonmetaType = "ReportSeries"
const CommonmetaTypeSoftware CommonmetaType = "Software"
const CommonmetaTypeStandard CommonmetaType = "Standard"
const CommonmetaTypeStudyRegistration CommonmetaType = "StudyRegistration"
const CommonmetaTypeWebPage CommonmetaType = "WebPage"

type ContributorRole string

const ContributorRoleAuthor ContributorRole = "Author"
const ContributorRoleChair ContributorRole = "Chair"
const ContributorRoleConceptualization ContributorRole = "Conceptualization"
const ContributorRoleContactPerson ContributorRole = "ContactPerson"
const ContributorRoleDataCollector ContributorRole = "DataCollector"
const ContributorRoleDataCuration ContributorRole = "DataCuration"
const ContributorRoleDataManager ContributorRole = "DataManager"
const ContributorRoleDistributor ContributorRole = "Distributor"
const ContributorRoleEditor ContributorRole = "Editor"
const ContributorRoleFormalAnalysis ContributorRole = "FormalAnalysis"
const ContributorRoleFundingAcquisition ContributorRole = "FundingAcquisition"
const ContributorRoleHostingInstitution ContributorRole = "HostingInstitution"
const ContributorRoleInvestigation ContributorRole = "Investigation"
const ContributorRoleMaintainer ContributorRole = "Maintainer"
const ContributorRoleMethodology ContributorRole = "Methodology"
const ContributorRoleOther ContributorRole = "Other"
const ContributorRoleProducer ContributorRole = "Producer"
const ContributorRoleProjectAdministration ContributorRole = "ProjectAdministration"
const ContributorRoleProjectLeader ContributorRole = "ProjectLeader"
const ContributorRoleProjectManager ContributorRole = "ProjectManager"
const ContributorRoleProjectMember ContributorRole = "ProjectMember"
const ContributorRoleReader ContributorRole = "Reader"
const ContributorRoleRegistrationAgency ContributorRole = "RegistrationAgency"
const ContributorRoleRegistrationAuthority ContributorRole = "RegistrationAuthority"
const ContributorRoleRelatedPerson ContributorRole = "RelatedPerson"
const ContributorRoleResearchGroup ContributorRole = "ResearchGroup"
const ContributorRoleResearcher ContributorRole = "Researcher"
const ContributorRoleResources ContributorRole = "Resources"
const ContributorRoleReviewAssistant ContributorRole = "ReviewAssistant"
const ContributorRoleReviewer ContributorRole = "Reviewer"
const ContributorRoleReviewerExternal ContributorRole = "ReviewerExternal"
const ContributorRoleRightsHolder ContributorRole = "RightsHolder"
const ContributorRoleSoftware ContributorRole = "Software"
const ContributorRoleSponsor ContributorRole = "Sponsor"
const ContributorRoleStatsReviewer ContributorRole = "StatsReviewer"
const ContributorRoleSupervision ContributorRole = "Supervision"
const ContributorRoleTranslator ContributorRole = "Translator"
const ContributorRoleValidation ContributorRole = "Validation"
const ContributorRoleVisualization ContributorRole = "Visualization"
const ContributorRoleWorkPackageLeader ContributorRole = "WorkPackageLeader"
const ContributorRoleWritingOriginalDraft ContributorRole = "WritingOriginalDraft"
const ContributorRoleWritingReviewEditing ContributorRole = "WritingReviewEditing"

type GeoLocationPoint struct {
	// PointLatitude corresponds to the JSON schema field "pointLatitude".
	PointLatitude Latitude `json:"pointLatitude" yaml:"pointLatitude" mapstructure:"pointLatitude"`

	// PointLongitude corresponds to the JSON schema field "pointLongitude".
	PointLongitude Longitude `json:"pointLongitude" yaml:"pointLongitude" mapstructure:"pointLongitude"`
}

type Latitude float64

type Longitude float64

var enumValues_CommonmetaArchiveLocationsElem = []interface{}{
	"CLOCKSS",
	"LOCKSS",
	"Portico",
	"KB",
	"Internet Archive",
	"DWT",
}
var enumValues_CommonmetaContainerType = []interface{}{
	"Book",
	"BookSeries",
	"Journal",
	"Proceedings",
	"ProceedingsSeries",
	"Repository",
	"DataRepository",
	"Periodical",
	"Series",
}
var enumValues_CommonmetaContributorsElemType = []interface{}{
	"Organization",
	"Person",
}
var enumValues_CommonmetaDescriptionsElemType = []interface{}{
	"Abstract",
	"Summary",
	"Methods",
	"TechnicalInfo",
	"Other",
}
var enumValues_CommonmetaFundingReferencesElemFunderIdentifierType = []interface{}{
	"Crossref Funder ID",
	"ROR",
	"GRID",
	"ISNI",
	"Ringgold",
	"Other",
}
var enumValues_CommonmetaProvider = []interface{}{
	"Crossref",
	"DataCite",
	"GitHub",
	"JaLC",
	"KISTI",
	"mEDRA",
	"OP",
	"InvenioRDM",
}
var enumValues_CommonmetaRelationsElemType = []interface{}{
	"IsNewVersionOf",
	"IsPreviousVersionOf",
	"IsVersionOf",
	"HasVersion",
	"IsPartOf",
	"HasPart",
	"IsVariantFormOf",
	"IsOriginalFormOf",
	"IsIdenticalTo",
	"IsTranslationOf",
	"HasTranslation",
	"IsReviewedBy",
	"Reviews",
	"HasReview",
	"IsPreprintOf",
	"HasPreprint",
	"IsSupplementTo",
	"IsSupplementedBy",
}
var enumValues_CommonmetaSchemaVersion = []interface{}{
	"https://commonmeta.org/commonmeta_v0.10",
	"https://commonmeta.org/commonmeta_v0.11",
	"https://commonmeta.org/commonmeta_v0.12",
	"http://datacite.org/schema/kernel-3",
	"http://datacite.org/schema/kernel-4",
}
var enumValues_CommonmetaState = []interface{}{
	"findable",
	"not_found",
	"forbidden",
	"bad_request",
}
var enumValues_CommonmetaTitlesElemType = []interface{}{
	"AlternativeTitle",
	"Subtitle",
	"TranslatedTitle",
}
var enumValues_CommonmetaType = []interface{}{
	"Article",
	"Audiovisual",
	"BookChapter",
	"BookPart",
	"BookSection",
	"BookSeries",
	"BookSet",
	"Book",
	"Collection",
	"Component",
	"Database",
	"Dataset",
	"Dissertation",
	"Document",
	"Entry",
	"Grant",
	"Image",
	"Instrument",
	"JournalArticle",
	"JournalIssue",
	"JournalVolume",
	"Journal",
	"PeerReview",
	"PhysicalObject",
	"Presentation",
	"ProceedingsArticle",
	"ProceedingsSeries",
	"Proceedings",
	"ReportComponent",
	"ReportSeries",
	"Report",
	"Software",
	"Standard",
	"StudyRegistration",
	"WebPage",
	"Other",
}
var enumValues_ContributorRole = []interface{}{
	"Author",
	"Editor",
	"Chair",
	"Reviewer",
	"ReviewAssistant",
	"StatsReviewer",
	"ReviewerExternal",
	"Reader",
	"Translator",
	"ContactPerson",
	"DataCollector",
	"DataManager",
	"Distributor",
	"HostingInstitution",
	"Producer",
	"ProjectLeader",
	"ProjectManager",
	"ProjectMember",
	"RegistrationAgency",
	"RegistrationAuthority",
	"RelatedPerson",
	"ResearchGroup",
	"RightsHolder",
	"Researcher",
	"Sponsor",
	"WorkPackageLeader",
	"Conceptualization",
	"DataCuration",
	"FormalAnalysis",
	"FundingAcquisition",
	"Investigation",
	"Methodology",
	"ProjectAdministration",
	"Resources",
	"Software",
	"Supervision",
	"Validation",
	"Visualization",
	"WritingOriginalDraft",
	"WritingReviewEditing",
	"Maintainer",
	"Other",
}
